import groovy.transform.Field

@Field def defaults = [
  actions: ['print_branches'],
  version: '0.0.0'
]
if (env.BRANCH_NAME == 'master' || env.BRANCH_NAME.startsWith('hotfix/v')) {
  defaults.branch_type = 'hotfix'
}
if (env.BRANCH_NAME == 'develop' || env.BRANCH_NAME.startsWith('release/v')) {
  defaults.branch_type = 'release'
}
if (env.BRANCH_NAME == 'master' || env.BRANCH_NAME == 'develop') {
  defaults.actions.add('start')
}
if (env.BRANCH_NAME ==~ /^(hotfix|release)\/v.+/) {
  defaults.actions.add('merge')
  defaults.actions.add('finish')
  defaults.actions.add('rename')
  defaults.actions.add('delete')
  defaults.actions.add('protect')
  defaults.actions.add('unprotect')
}

@Field def repos = [:], score = [:]
@Field String branch = ''
@Field ArrayList baseBranches = []

if (params.action in ['start', 'rename']) {
  branch = defaults.branch_type + '/v' + params.version
  baseBranches = [env.BRANCH_NAME]
} else if (params.action in ['merge', 'finish']) {
  branch = env.BRANCH_NAME
  baseBranches = ['master']
  if (params.action == 'finish')
    baseBranches += ['develop']
  if (!params.extra_branches.isEmpty())
    baseBranches.addAll(params.extra_branches.split(' '))
} else {
  branch = env.BRANCH_NAME
}

currentBuild.displayName += (params.action) ? ' / ' + params.action : ''
currentBuild.displayName += (params.action == 'start') ? ' ' + params.version : ''

pipeline {
  agent {
    label 'branch_manager'
  }
  environment {
    GIT_SERVER = 'git.onlyoffice.com'
    GIT_OWNER = 'ONLYOFFICE'
    GITEA_TOKEN = credentials('gitea-token')
    TELEGRAM_TOKEN = credentials('telegram-bot-token')
  }
  options {
    disableConcurrentBuilds()
    skipDefaultCheckout(true)
  }
  parameters {
    booleanParam(
      name: 'wipe',
      description: 'Wipe out current workspace'
    )
    choice(
      name: 'repo_list',
      choices: ['general', 'mobile', 'all'],
      description: 'Repo list'
    )
    choice(
      name: 'action',
      choices: defaults.actions,
      description: "Action type"
    )
    string(
      name: 'version',
      defaultValue: defaults.version,
      description: 'Release version (for start only) [' + defaults.branch_type + ']'
    )
    booleanParam(
      name: 'protect_branch',
      defaultValue: true,
      description: 'Protect branch (for start & rename only)'
    )
    string(
      name: 'extra_branches',
      description: 'Extra branches (space separated, for merge & finish only)'
    )
    booleanParam(
      name: 'notify',
      defaultValue: true,
      description: 'Telegram notification (for only start, merge & finish)'
    )
  }
  stages {
    stage('documents-pipeline') {
      when { expression { stageExpr() } }
      steps { start() }
    }
    stage('build_tools') {
      when { expression { stageExpr() } }
      steps { start() }
    }
    stage('core') {
      when { expression { stageExpr() } }
      steps { start() }
    }
    stage('desktop-apps') {
      when { expression { stageExpr() } }
      steps { start() }
    }
    stage('desktop-sdk') {
      when { expression { stageExpr() } }
      steps { start() }
    }
    stage('document-builder-package') {
      when { expression { stageExpr() } }
      steps { start() }
    }
    stage('document-server-package') {
      when { expression { stageExpr() } }
      steps { start() }
    }
    stage('onlyoffice') {
      when { expression { stageExpr() } }
      steps { start() }
    }
    stage('sdkjs') {
      when { expression { stageExpr() } }
      steps { start() }
    }
    stage('sdkjs-forms') {
      when { expression { stageExpr() } }
      steps { start() }
    }
    stage('sdkjs-ooxml') {
      when { expression { stageExpr() } }
      steps { start() }
    }
    stage('server') {
      when { expression { stageExpr() } }
      steps { start() }
    }
    stage('server-admin-panel') {
      when { expression { stageExpr() } }
      steps { start() }
    }
    stage('server-license') {
      when { expression { stageExpr() } }
      steps { start() }
    }
    stage('server-lockstorage') {
      when { expression { stageExpr() } }
      steps { start() }
    }
    stage('web-apps') {
      when { expression { stageExpr() } }
      steps { start() }
    }
    stage('web-apps-mobile') {
      when { expression { stageExpr() } }
      steps { start() }
    }
    stage('Docker-DocumentServer') {
      when { expression { stageExpr() } }
      steps { start() }
    }
    stage('DocumentBuilder') {
      when { expression { stageExpr() } }
      steps { start() }
    }
    stage('core-ext') {
      when { expression { stageExpr() } }
      steps { start() }
    }
    stage('document-android-editors') {
      when { expression { stageExpr() } }
      steps { start() }
    }
    stage('documents-app-android') {
      when { expression { stageExpr() } }
      steps { start() }
    }
    stage('documents-app-ios') {
      when { expression { stageExpr() } }
      steps { start() }
    }
    stage('editors-ios') {
      when { expression { stageExpr() } }
      steps { start() }
    }
    stage('sdkjs-native') {
      when { expression { stageExpr() } }
      steps { start() }
    }
  }
  post {
    always { script {
      score.success = repos.findAll { repo, result ->
        result.primary in ['skip', 'success']
      }.size()
      score.total = repos.size()

      println repos
      println score

      if (score.success == 0) {
        currentBuild.result = 'FAILURE'
      } else if (score.success != score.total) {
        currentBuild.result = 'UNSTABLE'
      } else if (score.success == score.total) {
        currentBuild.result = 'SUCCESS'
      }

      if (currentBuild.currentResult in ['FAILURE', 'UNSTABLE', 'SUCCESS']) {
        sendNotification()
      }
    } }
  }
}

Boolean stageExpr(String repo = STAGE_NAME) {
  switch(params.repo_list) {
    case 'all':
      return true
    case 'general':
      return repo in [
        'documents-pipeline',
        'build_tools',
        'core',
        'desktop-apps',
        'desktop-sdk',
        'document-builder-package',
        'document-server-package',
        'onlyoffice',
        'sdkjs',
        'sdkjs-forms',
        'sdkjs-ooxml',
        'server',
        'server-admin-panel',
        'server-license',
        'server-lockstorage',
        'web-apps',
        'web-apps-mobile',
        'Docker-DocumentServer',
        'DocumentBuilder'
      ]
    case 'mobile':
      return repo in [
        'core-ext',
        'document-android-editors',
        'documents-app-android',
        'documents-app-ios',
        'editors-ios',
        'sdkjs-native'
      ]
    default:
      return false
  }
}

def start(repo = STAGE_NAME) {

  Boolean pAction, sAction
  Map result = [:]

  if (params.action == 'print_branches') {

    pAction = printBranches(repo)
    if (!pAction) unstable('printBranches')
    result.primary = (pAction) ? 'success' : 'failure'

  } else if (params.action == 'start') {

    pAction = createBranch(repo, branch, baseBranches[0])
    if (!pAction) unstable('createBranch')
    result.primary = (pAction) ? 'success' : 'failure'
    if (params.protect_branch) {
      sAction = protectBranch(repo, branch)
      if (!sAction) unstable('protectBranch')
      result.secondary = (sAction) ? 'lock' : 'none'
    }

  } else if (params.action == 'merge') {

    if (!checkRemoteBranch(repo, branch)) {
      echo "${repo}: Branch doesn't ${branch} exist."
      result.primary = 'skip'
    } else {
      dir ('repos/' + repo) {
        if (params.wipe) deleteDir()
        checkoutRepo(repo)
        pAction = mergeBranch(repo, branch, baseBranches)
        if (!pAction) unstable('mergeBranch')
        result.primary = (pAction) ? 'success' : 'failure'
      }
    }

  } else if (params.action == 'finish') {

    if (!checkRemoteBranch(repo, branch)) {
      echo "${repo}: Branch doesn't ${branch} exist."
      result.primary = 'skip'
    } else {
      dir ('repos/' + repo) {
        if (params.wipe) deleteDir()
        checkoutRepo(repo)
        unprotectBranch(repo, branch)
        pAction = mergeBranch(repo, branch, baseBranches)
        if (!pAction) unstable('mergeBranch')
        result.primary = (pAction) ? 'success' : 'failure'
        if (pAction) {
          sAction = deleteBranch(repo, branch)
          if (!sAction) unstable('deleteBranch')
          result.secondary = (sAction) ? 'delete' : 'none'
        }
      }
    }

  } else if (params.action == 'rename') {

    if (checkRemoteBranch(repo, branch)) {
      echo "${repo}: Branch already ${branch} exists."
      result.primary = 'skip'
    } else {
      dir ('repos/' + repo) {
        if (params.wipe) deleteDir()
        checkoutRepo(repo, env.BRANCH_NAME)
        pAction = createBranch(repo, branch, env.BRANCH_NAME)
        if (!pAction) unstable('createBranch')
        result.primary = (pAction) ? 'success' : 'failure'
        if (pAction) {
          if (params.protect_branch) {
            sAction = protectBranch(repo, branch)
            if (!sAction) unstable('protectBranch')
            result.secondary = (sAction) ? 'lock' : 'none'
          }
          unprotectBranch(repo, env.BRANCH_NAME)
          deleteBranch(repo, env.BRANCH_NAME)
        }
      }
    }

  } else if (params.action == 'delete') {

    if (!checkRemoteBranch(repo, branch)) {
      echo "${repo}: Branch doesn't ${branch} exist."
      result.primary = 'skip'
    } else {
      dir ('repos/' + repo) {
        if (params.wipe) deleteDir()
        checkoutRepo(repo, branch)
        unprotectBranch(repo, branch)
        pAction = deleteBranch(repo, branch)
        if (!pAction) unstable('deleteBranch')
        result.primary = (pAction) ? 'success' : 'failure'
      }
    }

  } else if (params.action == 'protect') {

    pAction = protectBranch(repo, branch)
    result.primary = (pAction) ? 'success' : 'failure'

  } else if (params.action == 'unprotect') {

    pAction = unprotectBranch(repo, branch)
    result.primary = (pAction) ? 'success' : 'failure'

  }

  repos.put(repo, result)
  println result

}

def checkoutRepo(String repo, String branch = 'master') {
  sh (
    label: "${repo}: checkout".toUpperCase(),
    script: """
      if [ "\$(GIT_DIR=.git git rev-parse --is-inside-work-tree)" = 'true' ]; then
        git fetch --all --prune
        git switch -f ${branch}
        git reset --hard origin/${branch}
        git clean -df
      else
        rm -rfv ./*
        git clone -b ${branch} git@\$GIT_SERVER:\$GIT_OWNER/${repo}.git .
      fi
      git branch -vv
    """
  )
}

def checkRemoteBranch(String repo, String branch = 'master') {
  return sh (
    label: "${repo}: check branch ${branch}".toUpperCase(),
    script: "git ls-remote --exit-code git@\$GIT_SERVER:\$GIT_OWNER/${repo}.git ${branch}",
    returnStatus: true
  ) == 0
}

def createBranch(String repo, String branch, String baseBranch) {
  return sh (
    label: "${repo}: create branch ${branch}".toUpperCase(),
    script: """
      HTTP_CODE=\$(echo '{
        "new_branch_name": "${branch}",
        "old_ref_name": "${baseBranch}"
      }' | \
      curl -s -X 'POST' \
        "https://\$GIT_SERVER/api/v1/repos/\$GIT_OWNER/${repo}/branches" \
        -H "Authorization: token \$GITEA_TOKEN" \
        -H 'Content-Type: application/json' \
        -w '%{http_code}' \
        -o output.json \
        -d @-)
      jq -r '.' output.json
      test \$HTTP_CODE -eq 201 || test \$HTTP_CODE -eq 409
    """,
    returnStatus: true
  ) == 0
}

def mergeBranch(String repo, String branch, ArrayList baseBranches) {
  return sh (
    label: "${repo}: merge ${branch} into ${baseBranches.join(' ')}".toUpperCase(),
    script: """#!/bin/bash -xe
      git switch ${branch}
      git reset --hard origin/${branch}
      base_branches=(${baseBranches.join(' ')})
      merged=0
      rev_branch=\$(git rev-parse @)
      for base in "\${base_branches[@]}"; do
        git switch \$base || (((++merged)) && continue)
        git reset --hard origin/\$base
        rev_base=\$(git rev-parse @)
        if [[ \$rev_branch == \$rev_base ]]; then
          ((++merged))
          echo "No new commits."
          continue
        fi
        # gh pr create --repo \$GIT_OWNER/${repo} --base \$base --head ${branch} \
        #   --title "Merge branch ${branch} into \$base" --fill || \
        # true
        if ! git merge ${branch} --no-edit --no-ff \
          -m "Merge branch ${branch} into \$base"; then
          git merge --abort
          continue
        fi
        git push origin \$base
        ((++merged))
      done
      git branch -vv
      if [[ \$merged -ne \${#base_branches[@]} ]]; then
        echo "Not fully merged."
        exit 2
      fi
      echo "Branch merged."
    """,
    returnStatus: true
  ) == 0
}

def deleteBranch(String repo, String branch) {
  // if (repo == "documents-pipeline") return false
  return sh (
    label: "${repo}: delete ${branch}".toUpperCase(),
    script: """
      git switch -f master
      git branch -D ${branch}
      git push --delete origin ${branch}
      echo "Branch deleted."
    """,
    returnStatus: true
  ) == 0
}

def printBranches(String repo) {
  return sh (
    label: "${repo}: branches list".toUpperCase(),
    script: """
      HTTP_CODE=\$(curl -s -X 'GET' \
        "https://\$GIT_SERVER/api/v1/repos/\$GIT_OWNER/${repo}/branches" \
        -H "Authorization: token \$GITEA_TOKEN" \
        -w '%{http_code}' \
        -o output.json)
      test \$HTTP_CODE -eq 200
      jq -r '.[]|[.name, .protected]|@tsv' output.json | sort | column -t
    """,
    returnStatus: true
  ) == 0
}

def protectBranch(String repo, String branch) {
  String team
  if (repo == "documents-pipeline") {
    return false
  } else if (repo == "server-license") {
    team = "DEP-AD-Main-License"
  } else {
    team = "DEP-AD-Main-Leads"
  }
  return sh (
    label: "${repo}: protect ${branch}".toUpperCase(),
    script: """
      HTTP_CODE=\$(echo '{
        "branch_name": "${branch}",
        "enable_push": true,
        "enable_push_whitelist": true,
        "push_whitelist_teams": [
          "${team}",
          "Dep-Builder"
        ],
        "enable_merge_whitelist": true,
        "merge_whitelist_teams": [
          "${team}"
        ]
      }' | \
      curl -s -X 'POST' \
        "https://\$GIT_SERVER/api/v1/repos/\$GIT_OWNER/${repo}/branch_protections" \
        -H "Authorization: token \$GITEA_TOKEN" \
        -H 'Content-Type: application/json' \
        -w '%{http_code}' \
        -o output.json \
        -d @-)
      jq '.' output.json
      test \$HTTP_CODE -eq 201
    """,
    returnStatus: true
  ) == 0
}

def unprotectBranch(String repo, String branch) {
  return sh (
    label: "${repo}: unprotect ${branch}".toUpperCase(),
    script: """
      BRANCH=\$(echo -n "${branch}" | jq -sRr @uri)
      HTTP_CODE=\$(curl -s -X 'DELETE' \
        "https://\$GIT_SERVER/api/v1/repos/\$GIT_OWNER/${repo}/branch_protections/\$BRANCH" \
        -H "Authorization: token \$GITEA_TOKEN" \
        -w '%{http_code}' \
        -o output.json)
      jq '.' output.json
      test \$HTTP_CODE -eq 204 || test \$HTTP_CODE -eq 404
    """,
    returnStatus: true
  ) == 0
}

def sendNotification() {
  String chatId = '-1001346473906'
  String text = ''
  switch(params.action) {
    case 'start':
      text = "Branch `${branch}` created from `${baseBranches[0]}`"
      break
    case ['merge', 'finish']:
      text = "Branch `${branch}` merged into "
      text += baseBranches.collect({"`$it`"}).join(', ')
      break
    default: text = 'Stats'
  }
  text += " \\[${score.success}/${score.total}]"
  repos.each { repo, result ->
    text += '\n'
    switch(result.primary) {
      case 'skip':    text += 'ðŸ”˜'; break
      case 'success': text += 'â˜‘ï¸'; break
      case 'failure': text += 'ðŸš«'; break
      default:        text += 'âž–'
    }
    switch(result.secondary) {
      case 'lock':    text += 'ðŸ”’'; break
      case 'delete':  text += 'â™»ï¸'; break
      case 'none':    text += 'âž–'; break
      default:        text += ''
    }
    text += " [${repo}](https://${env.GIT_SERVER}/${env.GIT_OWNER}/${repo})"
  }

  if (params.action in ['start', 'merge', 'finish']
      && params.notify && score.success > 0) {
    sh label: "Send Telegram Message".toUpperCase(),
      script: "curl -X POST -s -S \
        -d chat_id=${chatId} \
        -d parse_mode=markdown \
        -d disable_web_page_preview=true \
        --data-urlencode text='${text}' \
        https://api.telegram.org/bot\$TELEGRAM_TOKEN/sendMessage"
  } else {
    echo text
  }
}
